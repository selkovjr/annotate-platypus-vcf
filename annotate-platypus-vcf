#!/usr/bin/env perl

# Add a set of tags to VCF annotations in Platypus output.
#
# ## Usage
#
# `annotate-platypus-vcf [-r reference.fa] < input.vcf > annotated.vcf`
#
# ## Annotations
#
# All annotations are added as new tags in the INFO column, including:
#
# * `TYPE=SNP|MNP|INS|DEL|COMPLEX|MATCH`
# * `CONS=SNP|MNP|INS|DEL|COMPLEX|MATCH`
#
use strict;
use warnings FATAL => qw[ all ];
use feature qw[ state say ];
use 5.010;

use English '-no_match_vars';
use Carp;
use Data::Dumper;

use File::Basename;
use IO::File;
use IO::Uncompress::Gunzip qw[ gunzip ];
use Vcf;
use FaSlice;
use Try::Tiny;
use AnyEvent::HTTP;
use JSON::XS qw[ decode_json ];
use Promises qw[ collect deferred ];

our $VERSION = 0.1;

use constant SUCCESS => 200;
my $REFERENCE;

#__________________________________________________________________
#
# ### Main program
#
# This code is derived from
# [vcf-convert](https://github.com/vcftools/vcftools/blob/master/src/perl/vcf-convert)
# and it retains some homology around data input and indel allele
# normalization.


# The only optional input is reference genome (-r) that is used to validate
# normalized indels. It is ignored while processing SNP-only VCFs.
my $opts = parse_params();
my $vcf_in  = Vcf->new(fh => \*STDIN);
$vcf_in->parse_header();

# #### Header

# Version change is a paranoid precaution against the possibility of new
# annotations being incompatible with VCF 4.0.
shift @{$vcf_in->{header_lines}}; # discard the version line
my $vcf_out = Vcf->new(version => '4.1');

# Copy the input header to the output stream, inserting new INFO tag
# descriptions in front of the old ones.
my $info_seen;
foreach my $line (@{$vcf_in->{header_lines}}) {
  if ($line->{key} eq 'INFO' and not $info_seen) { # The first INFO line
    $info_seen++;
    $vcf_out->add_header_line({
      key => 'INFO',
      ID => 'TYPE',
      Number => 'A',
      Type => 'String',
      Description => 'The type of allele: SNP, MNP, INS, DEL, or COMPLEX'
    });
    $vcf_out->add_header_line({
      key => 'INFO',
      ID => 'ARR',
      Number => 'A',
      Type => 'Float',
      Description => 'ALT to REF per cent ratio'
    });
  }
  $vcf_out->add_header_line($line); # The rest of the header
}
$vcf_out->add_columns(@{$vcf_in->{columns}});
print $vcf_out->format_header();

#
# #### Data
#

# Each VCF line
while (my $x = $vcf_in->next_data_hash()) {

  # **Local processing**
  fill_genotype_defaults($x);
  my $var_info = classify_variant($x);

  # If there is an indel, then a new set of left-aligned, minimized REF and ALT
  # alleles must be computed.

  if ( $var_info->{indel} ) {
    my ($map, $alt_to_mapref) = indel_maps($x, $vcf_in);

    # Use
    # [Vcf::fill_ref_alt_mapping()](http://search.cpan.org/dist/VCF-1.0/lib/VCF/V4_0.pm#fill_ref_alt_mapping)
    # to find the minimal reference segment containing all variants.
    $x->{REF} = $vcf_out->fill_ref_alt_mapping($map);
    if (not defined $x->{REF}) {
      error("Failed on line $x->{CHROM}:$x->{POS}");
    }

    for my $i (0 .. @{$x->{ALT}} - 1) {
      my $orig_ref = $alt_to_mapref->{$x->{ALT}[$i]}{ref};
      my $orig_alt = $alt_to_mapref->{$x->{ALT}[$i]}{alt};
      $x->{ALT}[$i] = $map->{$orig_ref}{$orig_alt};
    }
  }

  # **Fetch consequence predictions from ExAC**
  my $transaction = AnyEvent->condvar;

  # Make a separate request for each allele and lump them in a single promise
  collect (
    map { # a list of promises
      retrieve ( "http://exac.hms.harvard.edu/rest/variant/$_" )
    } @{$var_info->{allele}}
  )
  ->then (
    sub {
      # send all fulfilled promises to consumer, one for each allele
      $transaction->send(\@_);
    },
    sub { $transaction->croak( 'ERROR' ) }
  );

  # Block until all of this variant's alleles have been received
  my $response = $transaction->recv;

  # Gather allele-specific data to insert into INFO
  foreach my $allele ( map {$_->[0]} @{$response} ) {
    if ( $allele->{any_covered} and $allele->{variant}->{variant_id} ) {
      say $allele->{variant}->{variant_id};
      say sprintf '%7.5f', $allele->{variant}->{allele_freq};
      say $allele->{variant}->{allele_count};
      say $allele->{variant}->{allele_num};
      say join q{,}, @{$allele->{variant}->{genes}};
      say join q{,}, map {$_->{major_consequence}} @{$allele->{variant}->{vep_annotations}};
    }
    else {
    }
  }

  # **Add annotations and write the augmented variant**
  $x->{INFO}->{TYPE} = join q{,}, @{$var_info->{type}};

  print $vcf_out->format_line($x);

} # next_data_hash()

#__________________________________________________________________
#
# ### Functions
#

# **fill_genottype_defaults($var)**
#
# Add default FORMAT values not present in the input VCF
#
sub fill_genotype_defaults {
  my $var = shift;

  # This function's body was copied from
  # [vcf-convert](https://github.com/vcftools/vcftools/blob/master/src/perl/vcf-convert).
  for my $gt (values %{$var->{gtypes}}) {
    for my $field (@{$var->{FORMAT}}) {

      # Skip the GT tag, so that ploidy information is not lost (`./.` would become `.`)
      next if $field eq 'GT';

      if ( $field eq 'FT' and $gt->{$field} eq $vcf_in->{filter_passed}) {
        $gt->{$field} = $vcf_out->{filter_passed};
      }

      if (
        exists $vcf_in->{defaults}{$field} and
        $vcf_in->{defaults}{$field} eq $gt->{$field}
      ) {
        $gt->{$field} = $vcf_out->{defaults}{$field};
        next;
      }

      if (
        exists $gt->{$field} and
        exists $vcf_in->{header}{FORMAT}{$field}{default} and
        $vcf_in->{header}{FORMAT}{$field}{default} eq $gt->{$field}
      ) {
        delete $gt->{$field};
      }
    }
  }

  return 1;
}


#__________________________________________________________________
#
# **classify_variant($var)**
#
# Parse the ALT column and see if there are indels. To allow uniform treatment
# of mono-allelic and multi-allelic variants, return allele IDs (suitable for
# ExAC queries) and variant types as arrays.
#
sub classify_variant {
  my $var = shift;
  my $info = {
    allele => [],
    type => [],
  };

  # This function's body is derived from
  # [vcf-convert](https://github.com/vcftools/vcftools/blob/master/src/perl/vcf-convert).
  #
  for my $alt (@{$var->{ALT}}) {
    my ($type, $len, $ht) = $vcf_in->event_type($var, $alt);

    push @{$info->{allele}}, "$var->{CHROM}-$var->{POS}-$var->{REF}-$alt";

    if ( $type eq 's' ) {
      if ($len == 1) {
        push @{$info->{type}}, 'SNP';
      }
      else {
        if (length $var->{REF} == length $alt and length $alt == $len) {
          push @{$info->{type}}, 'MNP';
        }
        else {
          push @{$info->{type}}, 'COMPLEX';
        }
      }
      next;
    }

    if ( $type eq 'r' ) {
      push @{$info->{type}}, 'MATCH';
      next;
    }

    if ( $type ne 'i' ) {
      error("FIXME: expected indel at $var->{CHROM}:$var->{POS}");
    }

    if ($len > 0) {
      push @{$info->{type}}, 'INS';
    }
    else {
      push @{$info->{type}}, 'DEL';
    }

    $info->{indel}++;

  } # each ALT allele

  return $info;
} # classify_variant()


#__________________________________________________________________
#
# **indel_maps($var, $input_vcf)** -> $map, $alt_to_mapref
#
# Prepare a couple maps to unify REF and ALT alleles with
# [Vcf::fill_ref_alt_mapping()](http://search.cpan.org/dist/VCF-1.0/lib/VCF/V4_0.pm#fill_ref_alt_mapping).
#
# For example, for the variant `CTGTGTG -> C,CTG` the maps are constructed as:
#
# ```
# $map = {CTG => {C => 1}, CTGTG => {C => 1}}
# $alt_to_mapref = {
#   CTG => {ref => CTG, alt => C},
#   C => {ref => CTGTG, alt => C}
# }
# ```
# This function's body was copied (with modifications) from
# [vcf-convert](https://github.com/vcftools/vcftools/blob/master/src/perl/vcf-convert).
#
sub indel_maps {
  my ($var, $input_vcf) = @_;
  my $map = {};
  my $alt_to_mapref = {};

  for my $alt (@{$var->{ALT}}) {
    my ($type, $len, $ht) = $input_vcf->event_type($var, $alt);
    if ( $type eq 's' or $type eq 'r' ) { # SNP / MATCH
      $alt_to_mapref->{$alt} = {ref => $var->{REF}, alt => $alt};
      $map->{$var->{REF}}{$alt} = 1;
      next;
    }

    if ( $type eq 'i' and $len > 0 ) { # INS
      my $tmp = $var->{REF}.$ht;
      $alt_to_mapref->{$alt} = {ref => $var->{REF}, alt => $tmp};
      $map->{$var->{REF}}{$tmp} = 1;
      next;
    }
    elsif ( $type eq 'i' and $len < 0 ) { # DEL
      if ( not $REFERENCE ) {
        if ( not $opts->{refseq} ) {
          error('Indels present, missing the -r option.');
        }
        $REFERENCE = FaSlice->new(file => $opts->{refseq}, size => 1_000_000);
      }
      my $ref   = $REFERENCE->get_slice($var->{CHROM}, $var->{POS}, $var->{POS} + abs $len);
      my $nref1 = uc substr $ref, 0, 1;
      my $oref1 = uc substr $var->{REF}, 0, 1;

      if ( $oref1 ne $nref1 ) { # Sanity check
        error("Sanity check failed: the ref does not agree at $var->{CHROM}:$var->{POS} .. [$nref1] in .fa,  [$oref1] in .vcf");
      }

      $alt_to_mapref->{$alt} = { ref => $ref, alt => $nref1 };
      $map->{$ref}{$nref1} = 1;
      next;
    }
    else { # Unknown variant type
      error("Uh, FIXME: $var->{CHROM}:$var->{POS} [$type] [$len] [$ht]");
    }
  } # each allele

  return ($map, $alt_to_mapref);
}

#________________________________________________________________________
#
# **retrieve($uri)**
#
# Launch a web fetch request a URI. Return a promise to deliver a decoded
# JSON response.
#
sub retrieve {
  my ($uri) = @_;
  my $d = deferred;
  http_get $uri => sub {
    my ($body, $header) = @_;
    my $data;
    if ($header->{Status} == SUCCESS) {
      # Handle exceptions caused by non-JSON responses.
      try {
        # The server is set to gzip large response bodies
        if ($header->{'content-encoding'} and $header->{'content-encoding'} eq 'gzip') {
          my $buffer;
          gunzip \$body => \$buffer;
          $body = $buffer;
        }

        # HTML is returned in response to bad requests. Also, variants in
        # unlocalized contigs are greeted with a "Page not found" HTML
        # response.
        if (index($body, '<!doctype html>') >= 0) {
          $data = {any_covered => undef};
        }

        # Success
        else {
          $data = decode_json($body);
        }
      }
      catch {
        say {*STDERR} "$_ in response from $uri";

        my $fh = IO::File->new('bad-response.dump', '>');
        if (defined $fh) {
          print {$fh} Data::Dumper->Dump([$header, $body], [qw(header body)]);
          $fh->close;
        }

        $d->reject();
      };
      #say STDERR Dumper($data);

      $d->resolve($data);
    }
    else {
      $d->reject( $body );
    }
  };

  return $d->promise;
}

#________________________________________________________________________
#
# ## Utility functions
#
sub usage {
  my $self = basename $PROGRAM_NAME;

  say {*STDERR} <<"END";
  $self v$VERSION: add variation type and depth annotations; add consequence predictions from ExAC

  Usage: cat in.vcf | $self [OPTIONS] > out.vcf
  Options:
     -r, --refseq <file>    The reference sequence in samtools faindexed fasta file (not required with SNPs only)
     -h, -?, --help         This help message
END

  return 1;
}

sub error {
  my $msg = shift;
  croak $msg if $msg;
  usage();
  exit 1;
}

sub parse_params {
  my $o = {};
  while (my $arg = shift @ARGV) {
    if ( $arg eq '-r' or $arg eq '--refseq' ) {
      $o->{refseq} = shift @ARGV;
      next;
    }

    if ($arg eq q{-?} or $arg eq '-h' or $arg eq '--help') {
      usage();
      exit 1;
    }

    error("Unknown parameter \"$arg\". Run with -h for help.");
  }

  return $o;
}



