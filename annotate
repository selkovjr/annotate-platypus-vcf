#!/usr/bin/env perl

use strict;
use warnings FATAL => qw( all );
use feature qw/state say/;
use 5.010;

use Carp;
use Data::Dumper;

use Vcf;
use FaSlice;
use Bio::EnsEMBL::Registry;


sub usage {
  say STDERR <<END;
  About: Convert between VCF versions
  Usage: cat in.vcf | vcf-convert [OPTIONS] > out.vcf
  Options:
     -r, --refseq <file>    the reference sequence in samtools faindexed fasta file (Not required with SNPs only)
     -h, -?, --help         his help message
END
  exit 1;
}

sub error {
  my $msg = shift;
  croak $msg if $msg;
  usage();
}

sub parse_params {
  my $opts = {};
  while (my $arg = shift(@ARGV)) {
    if ( $arg eq '-r' || $arg eq '--refseq' ) {
      $$opts{refseq}=shift(@ARGV);
      next;
    }

    usage() if $arg eq '-?' || $arg eq '-h' || $arg eq '--help';

    error("Unknown parameter \"$arg\". Run with -h for help.");
  }
  return $opts;
}

my $opts = parse_params();
my $vcf_in  = Vcf->new(fh => \*STDIN);
my $vcf_out = Vcf->new(version => '4.1');

# Convert the header
$vcf_in->parse_header();
shift @{$$vcf_in{header_lines}}; # discard format version
my $info_seen;
foreach my $line (@{$$vcf_in{header_lines}}) {
  # Insert definitions for new info tags
  if ($line->{key} eq 'INFO' and not $info_seen) {
    $info_seen++;
    $vcf_out->add_header_line({
      key => 'INFO',
      ID => 'TYPE',
      Number => 'A',
      Type => 'String',
      Description => 'The type of allele: SNP, MNP, INS, DEL, or COMPLEX'
    });
  }

  # Carry on with the rest of the header
  $vcf_out->add_header_line($line);
}

$vcf_out->add_columns(@{$$vcf_in{columns}});
print $vcf_out->format_header();


# Each data line
my $fa;
while (my $x = $vcf_in->next_data_hash()) {
  # Convert missing (default) FORMAT values
  for my $gt (values %{$$x{gtypes}}) {
    for my $field (@{$$x{FORMAT}}) {
      # Skip the GT tag, so that ploidy information is not lost ("./." would become ".")
      next if $field eq 'GT';

      if ( $field eq 'FT' && $$gt{$field} eq $$vcf_in{filter_passed} ) {
        $$gt{$field} = $$vcf_out{filter_passed};
      }

      if ( exists($$vcf_in{defaults}{$field}) && $$vcf_in{defaults}{$field} eq $$gt{$field} ) {
        $$gt{$field} = $$vcf_out{defaults}{$field};
        next;
      }

      next unless exists($$gt{$field});

      if (
        exists($$vcf_in{header}{FORMAT}{$field}{default}) &&
        $$vcf_in{header}{FORMAT}{$field}{default} eq $$gt{$field}
      ) {
        delete $$gt{$field};
        next;
      }
    }
  }

  # Parse the ALT column and see if there are indels
  my @type;
  my $has_indel;
  for my $alt (@{$$x{ALT}}) {
    my ($type, $len, $ht) = $vcf_in->event_type($x, $alt);

    if ( $type eq 's' ) {
      if ($len == 1) {
        push @type, 'SNP';
      }
      else {
        if (length $$x{REF} == length $alt and length $alt == $len) {
          push @type, 'MNP';
        }
        else {
          push @type, 'COMPLEX';
        }
      }
      next;
    }

    if ( $type eq 'r' ) {
      push @type, 'MATCH';
      next;
    }

    if ( $type ne 'i' ) {
      error("FIXME: expected indel at $$x{CHROM}:$$x{POS}");
    }

    if ($len > 0) {
      push @type, 'INS';
    }
    else {
      push @type, 'DEL';
    }

    $has_indel++;
  }

  # If there is an indel, new REF and ALT must be changed
  if ( $has_indel ) {
    my $map = {};
    my $alt_to_mapref = {};

    for my $alt (@{$$x{ALT}}) {
      my ($type, $len, $ht) = $vcf_in->event_type($x, $alt);
      if ( $type eq 's' or $type eq 'r' ) {
        $$alt_to_mapref{$alt} = {ref => $$x{REF}, alt => $alt};
        $$map{$$x{REF}}{$alt} = 1;
        next;
      }

      if ( $type eq 'i' && $len > 0 ) {
        my $tmp = $$x{REF}.$ht;
        $$alt_to_mapref{$alt} = {ref => $$x{REF}, alt => $tmp};
        $$map{$$x{REF}}{$tmp} = 1;
        next;
      }
      elsif ( $type eq 'i' && $len < 0 ) {
        unless ( $fa ) {
          if ( !$$opts{refseq} ) {
            error("Indels present, missing the -r option.");
          }
          $fa = FaSlice->new(file => $$opts{refseq}, size => 1_000_000);
        }
        my $ref   = $fa->get_slice($$x{CHROM}, $$x{POS}, $$x{POS} + abs($len));
        my $nref1 = uc(substr($ref, 0, 1));
        my $oref1 = uc(substr($$x{REF}, 0, 1));

        # Sanity check
        if ( $oref1 ne $nref1 ) {
          error("Sanity check failed: the ref does not agree at $$x{CHROM}:$$x{POS} .. [$nref1] in .fa,  [$oref1] in .vcf");
        }

        $$alt_to_mapref{$alt} = { ref => $ref, alt => $nref1 };
        $$map{$ref}{$nref1} = 1;
        next;
      }
      else {
        error("Uh, FIXME: $$x{CHROM}:$$x{POS} [$type] [$len] [$ht]");
      }
    }

    $$x{REF} = $vcf_out->fill_ref_alt_mapping($map);
    error("Failed on line $$x{CHROM}:$$x{POS}") unless defined $$x{REF};

    for (my $i = 0; $i < @{$$x{ALT}}; $i++) {
      my $ori_ref = $$alt_to_mapref{$$x{ALT}[$i]}{ref};
      my $ori_alt = $$alt_to_mapref{$$x{ALT}[$i]}{alt};
      $$x{ALT}[$i] = $$map{$ori_ref}{$ori_alt};
    }

  } # has indel

  # Add new fields
  $$x{INFO}->{TYPE} = join(',', @type);
  print $vcf_out->format_line($x);
}
__END__
#my $registry = 'Bio::EnsEMBL::Registry';
#
#$registry->load_registry_from_db(
#  -host => 'ensembldb.ensembl.org',
#  -user => 'anonymous',
#);
#
#my $variation_adaptor = $registry->get_adaptor(
#  'human',     # species
#  'variation', # database type
#  'variation'  # object type
#);
#
#my $variation = $variation_adaptor->fetch_by_name('rs1333049');
#print Dumper($variation);
