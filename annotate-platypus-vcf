#!/usr/bin/env perl

use strict;
use warnings FATAL => qw[ all ];
use feature qw[ state say ];
use 5.010;

use English '-no_match_vars';
use Carp;
use Data::Dumper;

use File::Basename;
use IO::File;
use IO::Uncompress::Gunzip qw[ gunzip ];
use Vcf;
use FaSlice;
use Try::Tiny;
use AnyEvent::HTTP;
use JSON::XS qw[ decode_json ];
use Promises qw[ collect deferred ];

our $VERSION = 0.1;

# -------------------------------- sub main ------------------------------------
my $opts = parse_params();
my $vcf_in  = Vcf->new(fh => \*STDIN);
my $vcf_out = Vcf->new(version => '4.1');

# Convert the header
$vcf_in->parse_header();
shift @{$vcf_in->{header_lines}}; # discard format version

my $info_seen;
foreach my $line (@{$vcf_in->{header_lines}}) {
  # Insert definitions for new info tags
  if ($line->{key} eq 'INFO' and not $info_seen) {
    $info_seen++;
    $vcf_out->add_header_line({
      key => 'INFO',
      ID => 'TYPE',
      Number => 'A',
      Type => 'String',
      Description => 'The type of allele: SNP, MNP, INS, DEL, or COMPLEX'
    });
    $vcf_out->add_header_line({
      key => 'INFO',
      ID => 'ARR',
      Number => 'A',
      Type => 'Float',
      Description => 'ALT to REF per cent ratio'
    });
  }

  # Carry on with the rest of the header
  $vcf_out->add_header_line($line);
}

$vcf_out->add_columns(@{$vcf_in->{columns}});
print $vcf_out->format_header();


# For each VCF line
my $fa;
while (my $x = $vcf_in->next_data_hash()) {

  # Local processing
  # Convert missing (default) FORMAT values
  for my $gt (values %{$x->{gtypes}}) {
    for my $field (@{$x->{FORMAT}}) {
      # Skip the GT tag, so that ploidy information is not lost ("./." would become ".")
      next if $field eq 'GT';

      if ( $field eq 'FT' and $gt->{$field} eq $vcf_in->{filter_passed} ) {
        $gt->{$field} = $vcf_out->{filter_passed};
      }

      if ( exists $vcf_in->{defaults}{$field} and $vcf_in->{defaults}{$field} eq $gt->{$field} ) {
        $gt->{$field} = $vcf_out->{defaults}{$field};
        next;
      }

      if (
        exists $gt->{$field} and
        exists $vcf_in->{header}{FORMAT}{$field}{default} and
        $vcf_in->{header}{FORMAT}{$field}{default} eq $gt->{$field}
      ) {
        delete $gt->{$field};
      }
    }
  }

  # Parse the ALT column and see if there are indels
  my @allele;
  my @type;
  my @arr;
  my $has_indel;
  for my $alt (@{$x->{ALT}}) {
    my ($type, $len, $ht) = $vcf_in->event_type($x, $alt);

    push @allele, "$x->{CHROM}-$x->{POS}-$x->{REF}-$alt";

    if ( $type eq 's' ) {
      if ($len == 1) {
        push @type, 'SNP';
      }
      else {
        if (length $x->{REF} == length $alt and length $alt == $len) {
          push @type, 'MNP';
        }
        else {
          push @type, 'COMPLEX';
        }
      }
      next;
    }

    if ( $type eq 'r' ) {
      push @type, 'MATCH';
      next;
    }

    if ( $type ne 'i' ) {
      error("FIXME: expected indel at $x->{CHROM}:$x->{POS}");
    }

    if ($len > 0) {
      push @type, 'INS';
    }
    else {
      push @type, 'DEL';
    }

    $has_indel++;
  }

  # If there is an indel, new REF and ALT must be changed
  if ( $has_indel ) {
    my $map = {};
    my $alt_to_mapref = {};

    for my $alt (@{$x->{ALT}}) {
      my ($type, $len, $ht) = $vcf_in->event_type($x, $alt);
      if ( $type eq 's' or $type eq 'r' ) {
        $alt_to_mapref->{$alt} = {ref => $x->{REF}, alt => $alt};
        $map->{$x->{REF}}{$alt} = 1;
        next;
      }

      if ( $type eq 'i' and $len > 0 ) {
        my $tmp = $x->{REF}.$ht;
        $alt_to_mapref->{$alt} = {ref => $x->{REF}, alt => $tmp};
        $map->{$x->{REF}}{$tmp} = 1;
        next;
      }
      elsif ( $type eq 'i' and $len < 0 ) {
        if ( not $fa ) {
          if ( not $opts->{refseq} ) {
            error('Indels present, missing the -r option.');
          }
          $fa = FaSlice->new(file => $opts->{refseq}, size => 1_000_000);
        }
        my $ref   = $fa->get_slice($x->{CHROM}, $x->{POS}, $x->{POS} + abs $len);
        my $nref1 = uc substr $ref, 0, 1;
        my $oref1 = uc substr $x->{REF}, 0, 1;

        # Sanity check
        if ( $oref1 ne $nref1 ) {
          error("Sanity check failed: the ref does not agree at $x->{CHROM}:$x->{POS} .. [$nref1] in .fa,  [$oref1] in .vcf");
        }

        $alt_to_mapref->{$alt} = { ref => $ref, alt => $nref1 };
        $map->{$ref}{$nref1} = 1;
        next;
      }
      else {
        error("Uh, FIXME: $x->{CHROM}:$x->{POS} [$type] [$len] [$ht]");
      }
    }

    $x->{REF} = $vcf_out->fill_ref_alt_mapping($map);
    if (not defined $x->{REF}) {
      error("Failed on line $x->{CHROM}:$x->{POS}");
    }

    for my $i (0 .. @{$x->{ALT}} - 1) {
      my $ori_ref = $alt_to_mapref->{$x->{ALT}[$i]}{ref};
      my $ori_alt = $alt_to_mapref->{$x->{ALT}[$i]}{alt};
      $x->{ALT}[$i] = $map->{$ori_ref}{$ori_alt};
    }

  } # has indel

  # Add new fields
  $x->{INFO}->{TYPE} = join ',', @type;

  # External processing (ExAC)
  my $transaction = AnyEvent->condvar;

  # Make a separate request for each allele and lump them in a single promise
  collect (
    map { # a list of promises
      retrieve ( "http://exac.hms.harvard.edu/rest/variant/$_" )
    } @allele
  )
  ->then (
    sub {
      # send all fulfilled promises to consumer, one for each allele
      $transaction->send(\@_);
    },
    sub { $transaction->croak( 'ERROR' ) }
  );

  # Block until all of this variant's alleles have been received
  my $response = $transaction->recv;

  # Gather allele-specific data to insert into INFO
  foreach my $allele (map {$_->[0]} @$response) {
    if ($allele->{any_covered} and $allele->{variant}->{variant_id}) {
      say $allele->{variant}->{variant_id};
      say sprintf '%7.5f', $allele->{variant}->{allele_freq};
      say $allele->{variant}->{allele_count};
      say $allele->{variant}->{allele_num};
      say join ',', @{$allele->{variant}->{genes}};
      say join ',', map {$_->{major_consequence}} @{$allele->{variant}->{vep_annotations}};
    }
    else {
    }
  }
  print $vcf_out->format_line($x);

} # next_data_hash()

sub retrieve {
  my ($uri) = @_;
  my $d = deferred;
  http_get $uri => sub {
    my ($body, $header) = @_;
    my $data;
    if ($header->{Status} == 200) {
      try {
        if ($header->{'content-encoding'} and $header->{'content-encoding'} eq 'gzip') {
          my $buffer;
          gunzip \$body => \$buffer;
          $body = $buffer;
        }

        if (index($body, '<!doctype html>') >= 0) { # probably an error
          $data = {any_covered => undef};
        }
        else {
          $data = decode_json($body);
        }
      }
      catch {
        say {*STDERR} "$_ in response from $uri";

        my $fh = IO::File->new('bad-response.dump', '>');
        print {$fh} Data::Dumper->Dump([$header, $body], [qw(header body)]);
        close {$fh};

        $d->reject();
      };
      #say STDERR Dumper($data);

      $d->resolve($data);
    }
    else {
      $d->reject( $body );
    }
  };

  return $d->promise;
}

sub usage {
  my $self = basename $PROGRAM_NAME;

  say {*STDERR} <<"END";
  $self v$VERSION: add variation type and depth annotations; add consequence predictions from ExAC

  Usage: cat in.vcf | $self [OPTIONS] > out.vcf
  Options:
     -r, --refseq <file>    The reference sequence in samtools faindexed fasta file (not required with SNPs only)
     -h, -?, --help         This help message
END

  return 1;
}

sub error {
  my $msg = shift;
  croak $msg if $msg;
  usage();
  exit 1;
}

sub parse_params {
  my $o = {};
  while (my $arg = shift @ARGV) {
    if ( $arg eq '-r' or $arg eq '--refseq' ) {
      $o->{refseq} = shift @ARGV;
      next;
    }

    if ($arg eq '-?' or $arg eq '-h' or $arg eq '--help') {
      usage();
      exit 1;
    }

    error("Unknown parameter \"$arg\". Run with -h for help.");
  }

  return $o;
}



